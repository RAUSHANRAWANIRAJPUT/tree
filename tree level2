#include <bits/stdc++.h>
using namespace std;
struct Node {
public:
    int data;
    Node* left;
    Node* right;

    Node(int x) {
        data = x;
        left = nullptr;
        right = nullptr;
    }
};

void preorder(Node* root) {
    if (root == nullptr) return;
    cout << root->data << " ";
    preorder(root->left);
    preorder(root->right);
}

int sumOfNodes(Node* root) {
    if (root == nullptr) return 0;
    return root->data + sumOfNodes(root->left) + sumOfNodes(root->right);
}

// count total nodes
int countNodes(Node* root) {
    if (root == nullptr) return 0;
    return 1 + countNodes(root->left) + countNodes(root->right);
}

// count leaf nodes (recursive)
int countLeafNodes(Node* root) {
    if (root == nullptr) return 0;
    if (root->left == nullptr && root->right == nullptr) return 1;
    return countLeafNodes(root->left) + countLeafNodes(root->right);
}

// count leaf nodes (iterative using level-order)
int countLeafNodesIterative(Node* root) {
    if (root == nullptr) return 0;
    queue<Node*> q;
    q.push(root);
    int leafCount = 0;
    while (!q.empty()) {
        Node* node = q.front(); q.pop();
        if (node->left == nullptr && node->right == nullptr) {
            leafCount++;
        } else {
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
    }
    return leafCount;
}

// count non-leaf nodes 
int countNonLeafNodes(Node* root) {
    int total = countNodes(root);
    int leaf = countLeafNodes(root);
    return total - leaf;
}

void levelorder(Node* root) {
    if (root == nullptr) return;
    queue<Node*> q;
    q.push(root);
    while (!q.empty()) {
        Node* node = q.front(); q.pop();
        cout << node->data << " ";
        if (node->left) q.push(node->left);
        if (node->right) q.push(node->right);
    }
    cout << endl;
}

void sumOfLevel(Node* root) {
    if (root == nullptr) return;
    queue<Node*> q;
    q.push(root);
    int level = 0;
    while (!q.empty()) {
        int size = q.size();
        int sum = 0;
        for (int i = 0; i < size; ++i) {
            Node* node = q.front(); q.pop();
            sum += node->data;
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        cout << "sum of level " << level << " is " << sum << "\n";
        level++;
    }
}

// height (recursive) â€” number of nodes on longest path from root to leaf
int height(Node* root) {
    if (root == nullptr) return 0;
    return 1 + max(height(root->left), height(root->right));
}

// height (iterative) using level-order (levels count)
int heightIterative(Node* root) {
    if (root == nullptr) return 0;
    queue<Node*> q;
    q.push(root);
    int h = 0;
    while (!q.empty()) {
        int sz = q.size();
        for (int i = 0; i < sz; ++i) {
            Node* node = q.front(); q.pop();
            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        h++;
    }
    return h;
}

int main() {
    // build sample tree
    Node* root = new Node(1);
    root->left = new Node(2);
    root->right = new Node(3);
    root->left->left = new Node(4);
    root->right->right = new Node(5);

    cout << "preorder: ";
    preorder(root);
    cout << "\n";

    cout << "levelorder: ";
    levelorder(root);

    sumOfLevel(root);

    cout << "sum of nodes: " << sumOfNodes(root) << "\n";

    cout << "total nodes: " << countNodes(root) << "\n";
    cout << "leaf nodes (recursive): " << countLeafNodes(root) << "\n";
    cout << "leaf nodes (iterative): " << countLeafNodesIterative(root) << "\n";
    cout << "non-leaf nodes: " << countNonLeafNodes(root) << "\n";

    cout << "height (recursive): " << height(root) << "\n";
    cout << "height (iterative): " << heightIterative(root) << "\n";

    // free memory (simple cleanup)
    // (in practice you'd delete properly or use smart pointers)
    delete root->left->left;
    delete root->left;
    delete root->right->right;
    delete root->right;
    delete root;

    return 0;
}
